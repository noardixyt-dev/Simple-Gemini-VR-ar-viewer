<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Noardix Dual-Eye SLAM</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/alanross/AlvaAR/dist/alva_ar.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #ui { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 1000; background: #000; }
        button { background: #00e5ff; border: none; padding: 25px 50px; border-radius: 50px; font-size: 20px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui"><button id="start-btn">START DUAL-EYE AR</button></div>

    <script type="module">
        let renderer, scene, camLeft, camRight, alva, video, videoTexture, model;

        async function init() {
            // 1. GET RAW CAMERA (Fixes the "No Output" issue)
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: 1280, height: 720 } 
            });
            video = document.createElement('video');
            video.srcObject = stream;
            video.play();
            videoTexture = new THREE.VideoTexture(video);

            // 2. SETUP SLAM TRACKING
            alva = await AlvaAR.Initialize(1280, 720);

            // 3. SETUP THREE.JS
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            
            // Stereo Setup (One camera per eye)
            const aspect = (window.innerWidth / 2) / window.innerHeight;
            camLeft = new THREE.PerspectiveCamera(70, aspect, 0.1, 1000);
            camRight = new THREE.PerspectiveCamera(70, aspect, 0.1, 1000);
            
            // 4. THE PASSTHROUGH BACKGROUND (Rendered for both eyes)
            // We use a large plane that stays centered behind our view
            const bgGeo = new THREE.PlaneGeometry(16, 9);
            const bgMat = new THREE.MeshBasicMaterial({ map: videoTexture, depthTest: false });
            const bgMesh = new THREE.Mesh(bgGeo, bgMat);
            bgMesh.position.z = -10; 
            scene.add(bgMesh);

            // 5. THE 3D MODEL (Floating "Menu" Placeholder)
            const menuGeo = new THREE.BoxGeometry(1, 0.6, 0.05);
            const menuMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, metalness: 0.7, roughness: 0.2 });
            const menu = new THREE.Mesh(menuGeo, menuMat);
            menu.position.set(0, 0, -3); 
            scene.add(menu);
            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 2));

            // 6. ANIMATION LOOP
            function loop() {
                requestAnimationFrame(loop);

                // Update SLAM Tracking (Visual SLAM)
                const pose = alva.findPose(video); 
                if (pose) {
                    const m = new THREE.Matrix4().fromArray(pose);
                    m.decompose(camLeft.position, camLeft.quaternion, camLeft.scale);
                    camRight.quaternion.copy(camLeft.quaternion);
                    
                    // Separation for VR (IPD)
                    camLeft.position.x -= 0.03;
                    camRight.position.x += 0.03;

                    // Keep Background Mesh aligned with head movement
                    bgMesh.quaternion.copy(camLeft.quaternion);
                    bgMesh.position.copy(camLeft.position).add(new THREE.Vector3(0,0,-10).applyQuaternion(camLeft.quaternion));
                }

                // RENDER SIDE-BY-SIDE
                const w = window.innerWidth, h = window.innerHeight;
                renderer.setScissorTest(true);

                // Render Left Eye
                renderer.setViewport(0, 0, w / 2, h);
                renderer.setScissor(0, 0, w / 2, h);
                renderer.render(scene, camLeft);

                // Render Right Eye
                renderer.setViewport(w / 2, 0, w / 2, h);
                renderer.setScissor(w / 2, 0, w / 2, h);
                renderer.render(scene, camRight);
            }
            loop();
        }

        document.getElementById('start-btn').onclick = () => {
            document.getElementById('ui').style.display = 'none';
            init();
        };
    </script>
</body>
</html>

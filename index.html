<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hologram Matchmove AR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: fixed; top: 10px; left: 10px; z-index: 1000; display: flex; gap: 10px; }
        #start-overlay { position: fixed; inset: 0; background: #000; color: #fff; display: flex; align-items: center; justify-content: center; z-index: 2000; flex-direction: column; }
        button { background: #00e5ff; border: none; padding: 15px 25px; border-radius: 10px; font-weight: bold; cursor: pointer; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 30px; height: 30px; border: 2px solid white; transform: translate(-50%, -50%); border-radius: 50%; pointer-events: none; opacity: 0.5; }
    </style>
</head>
<body>
    <div id="start-overlay">
        <h1>STEREO PASSTHROUGH</h1>
        <button id="start-btn">START CAMERA & SENSORS</button>
    </div>

    <div id="ui">
        <button id="import-btn">IMPORT MODEL (.GLB)</button>
        <input type="file" id="file-input" accept=".glb" style="display:none">
    </div>

    <div id="crosshair"></div>

    <script type="module">
        let renderer, videoTexture, video;
        let bgScene, bgCam; // The "Room"
        let fgScene, camLeft, camRight; // The "Hologram"
        let modelContainer;
        let sensorOrientation = new THREE.Quaternion();

        async function init() {
            // 1. Setup Video (The Passthrough)
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } 
            });
            video = document.createElement('video');
            video.srcObject = stream;
            video.setAttribute('playsinline', '');
            await video.play();
            videoTexture = new THREE.VideoTexture(video);

            // 2. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);

            // 3. Setup Background (Room Plane)
            bgScene = new THREE.Scene();
            bgCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const bgMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({ map: videoTexture, depthTest: false, depthWrite: false })
            );
            bgScene.add(bgMesh);

            // 4. Setup Foreground (3D World)
            fgScene = new THREE.Scene();
            const aspect = (window.innerWidth / 2) / window.innerHeight;
            camLeft = new THREE.PerspectiveCamera(70, aspect, 0.01, 1000);
            camRight = new THREE.PerspectiveCamera(70, aspect, 0.01, 1000);

            modelContainer = new THREE.Group();
            fgScene.add(modelContainer);

            // Add Lighting for your model
            fgScene.add(new THREE.AmbientLight(0xffffff, 1));
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 7);
            fgScene.add(light);

            // Initial Placeholder
            const cube = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshNormalMaterial({wireframe: true}));
            cube.position.set(0, 0, -2);
            modelContainer.add(cube);

            // 5. Sensor Logic
            window.addEventListener('deviceorientation', (e) => {
                if (e.alpha === null) return;
                const alpha = THREE.MathUtils.degToRad(e.alpha);
                const beta = THREE.MathUtils.degToRad(e.beta);
                const gamma = THREE.MathUtils.degToRad(e.gamma);
                const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
                sensorOrientation.setFromEuler(euler);
            });

            // 6. Model Importer
            const fileInput = document.getElementById('file-input');
            document.getElementById('import-btn').onclick = () => fileInput.click();
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                const url = URL.createObjectURL(file);
                new THREE.GLTFLoader().load(url, (gltf) => {
                    modelContainer.clear(); // Remove placeholder
                    const model = gltf.scene;
                    model.position.set(0, 0, -2); // Place in front of camera
                    modelContainer.add(model);
                });
            };

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update Perspective Cameras
            camLeft.quaternion.copy(sensorOrientation);
            camRight.quaternion.copy(sensorOrientation);
            
            // Stereo Offset
            camLeft.position.set(-0.03, 0, 0);
            camRight.position.set(0.03, 0, 0);

            const w = window.innerWidth, h = window.innerHeight;
            renderer.setScissorTest(true);

            // LEFT EYE
            renderer.setViewport(0, 0, w/2, h);
            renderer.setScissor(0, 0, w/2, h);
            renderer.clear();
            renderer.render(bgScene, bgCam); // The Real Room
            renderer.render(fgScene, camLeft); // The Hologram

            // RIGHT EYE
            renderer.setViewport(w/2, 0, w/2, h);
            renderer.setScissor(w/2, 0, w/2, h);
            renderer.clearDepth(); // Keep the room, just clear 3D depth
            renderer.render(bgScene, bgCam); // The Real Room
            renderer.render(fgScene, camRight); // The Hologram
        }

        document.getElementById('start-btn').onclick = () => {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(init);
            } else { init(); }
            document.getElementById('start-overlay').style.display = 'none';
        };
    </script>
</body>
</html>
